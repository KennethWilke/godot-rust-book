<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The godot-rust Book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/setup.html"><strong aria-hidden="true">2.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="getting-started/hello-world.html"><strong aria-hidden="true">2.2.</strong> Hello, world!</a></li></ol></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">3.</strong> FAQ</a></li><li class="chapter-item expanded "><a href="gdnative-overview.html"><strong aria-hidden="true">4.</strong> (TODO) An Overview of GDNative</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">5.</strong> (TODO) Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="testing/structure.html"><strong aria-hidden="true">5.1.</strong> Structuring Code for Testing</a></li><li class="chapter-item expanded "><a href="testing/engine.html"><strong aria-hidden="true">5.2.</strong> Testing with the Engine</a></li></ol></li><li class="chapter-item expanded "><a href="exporting.html"><strong aria-hidden="true">6.</strong> Exporting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exporting/android.html"><strong aria-hidden="true">6.1.</strong> Android</a></li><li class="chapter-item expanded "><a href="exporting/ios.html"><strong aria-hidden="true">6.2.</strong> (TODO) iOS</a></li><li class="chapter-item expanded "><a href="exporting/macosx.html"><strong aria-hidden="true">6.3.</strong> Mac OS X</a></li></ol></li><li class="chapter-item expanded "><a href="advanced-guides.html"><strong aria-hidden="true">7.</strong> Advanced Guides</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced-guides/custom-bindings.html"><strong aria-hidden="true">7.1.</strong> Using custom builds of Godot</a></li></ol></li><li class="chapter-item expanded "><a href="migrating-0-8.html"><strong aria-hidden="true">8.</strong> Migrating from godot-rust 0.8.x</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The godot-rust Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Welcome to the <code>godot-rust</code> book! This is a work-in-progress user guide for the Rust bindings to GDNative.</p>
<p>If you're new to <code>godot-rust</code>, try the <a href="./getting-started.html">Getting Started</a> tutorial first!</p>
<p>If you have used earlier versions of <code>godot-rust</code> before, see <a href="./migrating-0-8.html">Migrating from godot-rust 0.8.x</a> for a quick guided tour to the new API.</p>
<h2><a class="header" href="#contributing" id="contributing">Contributing</a></h2>
<p>The source repository for this book is <a href="https://github.com/godot-rust/book">hosted on GitHub</a>.</p>
<h2><a class="header" href="#license" id="license">License</a></h2>
<p>The <code>godot-rust</code> bindings, and this user guide, are licensed under the <a href="LICENSE.html">MIT license</a>.</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>The getting started tutorial will introduce you to basic godot-rust concepts. At the end of the tutorial, you'll have a working copy of the <a href="https://github.com/godot-rust/godot-rust/tree/master/examples/dodge_the_creeps">dodge-the-creeps example</a> from the main repo.</p>
<p>This tutorial assumes some experience with Godot's GUI and GDScript. It assumes a basic understanding of Rust itself.</p>
<h2><a class="header" href="#work-in-progress" id="work-in-progress">Work-in-progress</a></h2>
<p><strong>The Getting Started tutorial is a work-in-progress, and currently it only covers up to the hello-world example!</strong> To learn more about the API after the tutorial, you'll have to dive into the <a href="https://docs.rs/gdnative/0.9">documentation on docs.rs</a>, and the <a href="https://github.com/godot-rust/godot-rust/tree/master/examples/">other examples in the main repo</a>. If you have any questions using the bindings, ask away in the <code>#gdnative_dev</code> channel on the <a href="https://godotengine.org/community">Godot Engine community Discord server</a>!</p>
<h1><a class="header" href="#setup" id="setup">Setup</a></h1>
<p>Before we can start creating a hello-world project using godot-rust, we'll need to install the necessary software.</p>
<h2><a class="header" href="#godot-engine" id="godot-engine">Godot Engine</a></h2>
<p>The default API version is currently 3.2.3-stable. For the rest of the tutorial, we'll assume that you have Godot 3.2.3-stable installed, and available in your <code>PATH</code> as <code>godot</code>.</p>
<p>You may download binaries of Godot 3.2.3-stable from the official repository: <a href="https://downloads.tuxfamily.org/godotengine/3.2.3/">https://downloads.tuxfamily.org/godotengine/3.2.3/</a>.</p>
<blockquote>
<h3><a class="header" href="#using-another-build-of-the-engine" id="using-another-build-of-the-engine">Using another build of the engine</a></h3>
<p>For simplicity, we assume that you use the official build of 3.2.3-stable for the Getting Started tutorial. If you want to use another version of the engine, see the <a href="getting-started/../advanced-guides/custom-bindings.html">Using custom builds of Godot</a> guide.</p>
</blockquote>
<h2><a class="header" href="#rust" id="rust">Rust</a></h2>
<p><a href="https://rustup.rs/">rustup</a> is the recommended way to install the Rust toolchain, including the compiler, standard library, and Cargo, the package manager. Visit <a href="https://rustup.rs/">https://rustup.rs/</a> to see instructions for your platform.</p>
<p>After installation of rustup and the <code>stable</code> toolchain, check that they were installed properly:</p>
<pre><code class="language-bash"># Check Rust toolchain installer version
rustup -V
# Check Rust version
rustc --version
# Check Cargo version
cargo -V
</code></pre>
<h3><a class="header" href="#windows" id="windows">Windows</a></h3>
<p>When working on Windows, it's also necessary to install the <a href="https://visualstudio.microsoft.com/visual-cpp-build-tools/">Visual Studio Build Tools</a>, or the full Visual Studio (<em>not</em> Visual Studio Code). More details can be found on <a href="https://github.com/rust-lang/rustup#working-with-rust-on-windows">Working with Rust on Windows</a>.</p>
<h2><a class="header" href="#llvm" id="llvm">LLVM</a></h2>
<p>The godot-rust bindings depend on <code>bindgen</code>, which in turn <a href="https://rust-lang.github.io/rust-bindgen/requirements.html">depends on LLVM</a>. You may download LLVM binaries from <a href="https://releases.llvm.org/">https://releases.llvm.org/</a>.</p>
<p>After installation, check that LLVM was installed properly:</p>
<pre><code class="language-bash"># Check if Clang is installed and registered in PATH
clang -v
</code></pre>
<h1><a class="header" href="#hello-world" id="hello-world">Hello, world!</a></h1>
<p>Follow this tutorial to learn how to create an empty project that simply prints &quot;Hello, world!&quot; to the Godot console on ready. The code might not compile or work as intended while it's in-progress, but at the end of this section, the code will be compiling and working fine.</p>
<p>The full, finished code is available in the main repo: <a href="https://github.com/godot-rust/godot-rust/tree/master/examples/hello_world">https://github.com/godot-rust/godot-rust/tree/master/examples/hello_world</a>.</p>
<h2><a class="header" href="#creating-the-project" id="creating-the-project">Creating the project</a></h2>
<p>First, create an empty project using the Godot GUI. Then, create an empty crate <em>beside</em> the project folder using <code>cargo</code>:</p>
<pre><code class="language-sh">cargo init --lib my-gdnative-lib
</code></pre>
<p>Your file structure should look like this:</p>
<pre><code>.
├─── my-gdnative-lib
│   ├─── src
│   │   ├   lib.rs
│   ├   Cargo.toml
├─── my-godot-project
│   ├─── .import
│   ├   icon.png
│   ├   icon.png.import
│   └   project.godot
</code></pre>
<p>Once the project is created, open <code>Cargo.toml</code>, change the crate type to <code>cdylib</code>, and add <code>gdnative</code> as a dependency:</p>
<pre><code class="language-toml">[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
gdnative = &quot;0.9&quot;
</code></pre>
<blockquote>
<h3><a class="header" href="#organization-of-rust-code" id="organization-of-rust-code">Organization of Rust code</a></h3>
<p>While it's also possible to place the Rust crate within the Godot project, doing so might lead to problems with Godot's resource importer. It's best to place the Rust crate somewhere outside the Godot project directory.</p>
<p>Previously, some third-party resources have recommended separating Rust code into multiple crates. While this is fine to do, godot-rust works best when there is a single <code>cdylib</code> crate acting as the entry point for all crates in the workspace. Script downcasting, for example, only works for types registered in the same GDNative library. Code from <code>std</code> and other dependencies can also lead to code bloat when duplicated in multiple binaries.</p>
<p>We suggest that users start projects as a single crate, and only split code into workspaces when necessary.</p>
</blockquote>
<h2><a class="header" href="#boilerplate" id="boilerplate">Boilerplate</a></h2>
<p>You should now be able to compile your crate into a dynamic library, but a little bit of boilerplate is required before Godot can actually be able to load it as a GDNative library. Replace the contents of <code>lib.rs</code> with the following code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use gdnative::prelude::*;

// Function that registers all exposed classes to Godot
fn init(handle: InitHandle) {
}

// Macro that creates the entry-points of the dynamic library.
godot_init!(init);
<span class="boring">}
</span></code></pre></pre>
<p>The code does several things:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use gdnative::prelude::*;
<span class="boring">}
</span></code></pre></pre>
<p>This imports a number of commonly used types and traits into the scope. Generally, you'll want this at the top of every file where you need to interact with GDNative.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Function that registers all exposed classes to Godot
fn init(handle: InitHandle) {
}
<span class="boring">}
</span></code></pre></pre>
<p>This declares an empty callback function, which is called when the library is loaded by Godot. All script classes in the library should be &quot;registered&quot; here using <code>handle.add_class::&lt;MyNativeClass&gt;()</code>. You only need <em>one</em> of this in the entire library.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Macro that creates the entry-points of the dynamic library.
godot_init!(init);
<span class="boring">}
</span></code></pre></pre>
<p>This macro defines the necessary C callbacks used by Godot. You only need <em>one</em> invocation of this macro in the entire library. Note how the <code>init</code> function defined earlier is given to the <code>godot_init!</code> macro as a callback.</p>
<blockquote>
<h3><a class="header" href="#gdnative-internals" id="gdnative-internals">GDNative internals</a></h3>
<p>The purposes of this macro will be discussed in detail in <a href="getting-started/../gdnative-overview.html"><em>An Overview of GDNative</em></a>. For now, treat it as a magic incantation.</p>
</blockquote>
<h2><a class="header" href="#your-first-script" id="your-first-script">Your first script</a></h2>
<p>With the boilerplate put into place, you can now create your first Rust script! We will go step by step and discover what's needed to create script &quot;classes&quot;. Intermediate code versions might not compile, but at the end of this section it should be working!</p>
<p>A script is simply a Rust type that implements (derives) the <code>NativeScript</code> trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The HelloWorld &quot;class&quot;
#[derive(NativeClass)]
#[inherit(Node)]
pub struct HelloWorld;

// Function that registers all exposed classes to Godot
fn init(handle: InitHandle) {
    // Register the new `HelloWorld` type we just declared.
    handle.add_class::&lt;HelloWorld&gt;();
}
<span class="boring">}
</span></code></pre></pre>
<p>Similar to the GDScript <code>extends</code> directive, the <code>inherit</code> attribute tells godot-rust the most general base class your script can be attached to. Here, <code>Node</code> is the parent class of all nodes in the scene tree, so it would be possible to attach <code>HelloWorld</code> to any node or scene in Godot.</p>
<p>Unfortunately, this won't compile just yet: Rust will complain about the lack of a <code>new</code> method and a <code>NativeClassMethods</code> trait. This is because all scripts must also have a zero-argument constructor and a set of exported methods. To fix this, simply add two <code>impl</code> blocks:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// You may add any number of ordinary `impl` blocks as you want. However, ...
impl HelloWorld {
    /// The &quot;constructor&quot; of the class.
    fn new(_owner: &amp;Node) -&gt; Self {
        HelloWorld
    }
}

// Only __one__ `impl` block can have the `#[methods]` attribute, which
// will generate code to automatically bind any exported methods to Godot.
#[methods]
impl HelloWorld {
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>HelloWorld</code> type is like any regular Rust type, and can have any number of ordinary <code>impl</code> blocks. However, it must have <strong>one and only one</strong> <code>impl</code> block with the <code>#[methods]</code> attribute, which tells godot-rust to generate code that automatically binds any exported methods to Godot.</p>
<h2><a class="header" href="#creating-the-nativescript-resource" id="creating-the-nativescript-resource">Creating the NativeScript resource</a></h2>
<p>You should now be able to build the dynamic library with a <code>HelloWorld</code> script class in it. However, we also need to tell Godot about it. To do this, build the library with <code>cargo build</code>.</p>
<p>After building the library with <code>cargo build</code>, the resulting library should be in the <code>target/debug/</code> folder. Copy it (or create a symbolic link to it) somewhere inside the Godot project directory.</p>
<p>To tell Godot about the <code>HelloWorld</code> class, a <code>GDNativeLibrary</code> resource has to be created. This can be done in the &quot;Inspector&quot; panel in the Godot editor by clicking the &quot;new resource&quot; button in the top left.</p>
<p>With the <code>GDNativeLibrary</code> resource created, the path to the generated binary can be set in the editor. After specifying the path, save the <code>GDNativeLibrary</code> resource into a resource file by clicking the &quot;tool&quot; button in the Inspector panel in the top right.</p>
<p>Now, the <code>HelloWorld</code> class can be added to any node by clicking the &quot;add script&quot; button. In the popup, select &quot;NativeScript&quot; as the language, and set the class name to <code>HelloWorld</code>. Then, select the <code>NativeScript</code> resource in the Inspector, click the <code>library</code> field and point to the <code>GDNativeLibrary</code> resource that you created earlier.</p>
<h2><a class="header" href="#overriding-a-godot-method" id="overriding-a-godot-method">Overriding a Godot method</a></h2>
<p>You can now run your project from the editor! If all goes correctly, it should launch but do nothing. That's because we haven't added any actual behaviors yet! To make our script actually do something, we can override the <a href="https://docs.godotengine.org/en/stable/classes/class_node.html#class-node-method-ready"><code>_ready</code></a> method in the <code>impl</code> block with the <code>#[methods]</code> attribute:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Only __one__ `impl` block can have the `#[methods]` attribute, which
// will generate code to automatically bind any exported methods to Godot.
#[methods]
impl HelloWorld {

    // To make a method known to Godot, use the #[export] attribute.
    // In Godot, script &quot;classes&quot; do not actually inherit the parent class.
    // Instead, they are &quot;attached&quot; to the parent object, called the &quot;owner&quot;.
    //
    // In order to enable access to the owner, it is passed as the second
    // argument to every single exposed method. As a result, all exposed
    // methods MUST have `owner: &amp;BaseClass` as their second arguments,
    // before all other arguments in the signature.
    #[export]
    fn _ready(&amp;self, _owner: &amp;Node) {
        // The `godot_print!` macro works like `println!` but prints to the Godot-editor
        // output tab as well.
        godot_print!(&quot;Hello, world!&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, the <code>#[export]</code> attribute is used to tell godot-rust to expose your methods to Godot. In this case, we are overriding <a href="https://docs.godotengine.org/en/stable/classes/class_node.html#class-node-method-ready"><code>_ready</code></a> and printing a line of text.</p>
<p>Now, re-compile the crate using <code>cargo build</code> and copy the resulting binary to the Godot project. Launch the project from the editor, and you should see <code>Hello, world!</code> in the Godot console!</p>
<h2><a class="header" href="#wrapping-it-up" id="wrapping-it-up">Wrapping it up</a></h2>
<p>Congratulations! You have just created your first Rust GDNative library. You have learned how to expose scripts and methods to Godot using the bindings, and how to use them in Godot. A lot of the details are still unexplained, but you're off to a good start!</p>
<p>You can find the full code for this example in the main repo: <a href="https://github.com/godot-rust/godot-rust/tree/master/examples/hello_world">https://github.com/godot-rust/godot-rust/tree/master/examples/hello_world</a>.</p>
<h2><a class="header" href="#work-in-progress-1" id="work-in-progress-1">Work-in-progress</a></h2>
<p><strong>The Getting Started tutorial is a work-in-progress, and unfortunately it ends here for now!</strong> To learn more about the API, you'll have to dive into the <a href="https://docs.rs/gdnative/0.9">documentation on docs.rs</a>, and the <a href="https://github.com/godot-rust/godot-rust/tree/master/examples/">other examples in the main repo</a>. If you have any questions using the bindings, ask away in the <code>#gdnative_dev</code> channel on the <a href="https://godotengine.org/community">Godot Engine community Discord server</a>!</p>
<h1><a class="header" href="#faq" id="faq">FAQ</a></h1>
<h2><a class="header" href="#avoiding-a-borrowfailed-error-on-method-call" id="avoiding-a-borrowfailed-error-on-method-call">Avoiding a <code>BorrowFailed</code> error on method call</a></h2>
<p><strong>Question</strong></p>
<p>What is the <code>BorrowFailed</code> error and why do I keep getting it? I'm only trying to call another method that takes <code>&amp;mut self</code> while holding one!</p>
<p><strong>Answer</strong></p>
<p>In Rust, <a href="https://docs.rs/dtolnay/0.0.9/dtolnay/macro._02__reference_types.html">there can only be <em>one</em> <code>&amp;mut</code> reference to the same memory location at the same time</a>. To enforce this while making simple use cases easier, the bindings make use of <a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">interior mutability</a>. This works like a lock: whenever a method with <code>&amp;mut self</code> is called, it will try to obtain a lock on the <code>self</code> value, and hold it <em>until it returns</em>. As a result, if another method that takes <code>&amp;mut self</code> is called in the meantime for whatever reason (e.g. signals), the lock will fail and an error (<code>BorrowFailed</code>) will be produced.</p>
<p>It's relatively easy to work around this problem, though: Because of how the user-data container works, it can only see the outermost layer of your script type - the entire structure. This is why it's stricter than what is actually required. If you run into this problem, you can <a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">introduce finer-grained interior mutability</a> in your own type, and modify the problematic exported methods to take <code>&amp;self</code> instead of <code>&amp;mut self</code>.</p>
<h2><a class="header" href="#passing-additional-arguments-to-a-class-constructor" id="passing-additional-arguments-to-a-class-constructor">Passing additional arguments to a class constructor</a></h2>
<p><strong>Question</strong></p>
<p>A native script type needs to implement <code>fn new(owner: &amp;Node) -&gt; Self</code>.
Is it possible to pass additional arguments to <code>new</code>?</p>
<p><strong>Answer</strong></p>
<p>Unfortunately this is currently a general limitation of GDNative (see <a href="https://github.com/godotengine/godot/issues/23260">related issue</a>).</p>
<p>As a result, a common pattern to work-around the limitation is to use explicit initialization methods. For instance:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
#[inherit(Object)]
struct DataWrapper {
    data: Option&lt;Data&gt;,
}

#[godot::methods]
impl DataWrapper {
    fn new(_owner: &amp;Object) -&gt; Self {
        DataWrapper {
            data: None,
        }
    }

    #[export]
    fn set_data(&amp;mut self, _owner: &amp;Object, additional_arg1: i32, additional_arg2: i32) {
        self.data = Some(Data::new(additional_arg1, additional_arg2));
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#static-methods" id="static-methods">Static methods</a></h2>
<p><strong>Question</strong></p>
<p>In GDScript, classes can have static methods.
However, when I try to omit <code>self</code> in the exported method signature, I'm getting a compile error.
How can I implement a static method?</p>
<p><strong>Answer</strong></p>
<p>This is another limitation of GDNative -- static methods are not supported in general.</p>
<p>As a work-around, it is possible to use a ZST (zero-sized type):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass, Copy, Clone, Default)]
#[user_data(Aether&lt;StaticUtil&gt;)]
#[inherit(Object)]
pub struct StaticUtil;

#[godot::methods]
impl StaticUtil {
    #[export]
    fn compute_something(&amp;self, _owner: &amp;Object, input: i32) -&gt; i32 {
        godot_print!(&quot;pseudo-static computation&quot;);
        2 * input
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://docs.rs/gdnative/0.9/gdnative/prelude/struct.Aether.html"><code>Aether</code></a> is a special user-data wrapper intended for zero-sized types, that does not perform any allocation or synchronization at runtime.</p>
<p>The type needs to be instantiated somewhere on GDScript level.
Good places for instantiation are for instance:</p>
<ul>
<li>as a member of a long-living util object,</li>
<li>as a <a href="https://docs.godotengine.org/en/stable/getting_started/step_by_step/singletons_autoload.html">singleton auto-load object</a>.</li>
</ul>
<h2><a class="header" href="#converting-a-godot-type-to-the-underlying-rust-type" id="converting-a-godot-type-to-the-underlying-rust-type">Converting a Godot type to the underlying Rust type</a></h2>
<p><strong>Question</strong></p>
<p>I have a method that takes an argument <code>my_object</code> as a <code>Variant</code>.
I know that this object has a Rust native script attached to it, called say <code>MyObject</code>.
How can I access the Rust type given the Variant?</p>
<p><strong>Answer</strong></p>
<p>This conversion can be accomplished by casting the <code>Variant</code> to a <code>Ref</code>, and then to an <code>Instance</code> or <code>RefInstance</code>, and mapping over it to access the Rust data type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[godot::methods]
impl AnotherNativeScript {

    #[export]
    pub fn method_accepting_my_object(&amp;self, _owner: &amp;Object, my_object: Variant) {
        // 1. Cast Variant to Ref of associated Godot type, and convert to TRef.
        let my_object = unsafe {
            my_object
                .try_to_object::&lt;Object&gt;()
                .expect(&quot;Failed to convert my_object variant to object&quot;)
                .assume_safe()
        };
        // 2. Obtain a RefInstance.
        let my_object = my_object
            .cast_instance::&lt;MyObject&gt;()
            .expect(&quot;Failed to cast my_object object to instance&quot;);
        // 3. Map over the RefInstance to extract the underlying user data.
        my_object
            .map(|my_object, _owner| {
                // Now my_object is of type MyObject.
            })
            .expect(&quot;Failed to map over my_object instance&quot;);
    }

}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#auto-completion-with-rust-analyzer" id="auto-completion-with-rust-analyzer">Auto-completion with rust-analyzer</a></h2>
<p><strong>Question</strong></p>
<p><code>godot-rust</code> generates most of the gdnative type's code at compile-time. Editors using <a href="https://github.com/rust-analyzer/rust-analyzer">rust-analyzer</a> struggle to autocomplete those types:</p>
<p><img src="images/no-completion.png" alt="no-completion" /></p>
<p><strong>Answer</strong></p>
<p>People <a href="https://github.com/rust-analyzer/rust-analyzer/issues/5040">reported</a> similar issues and found that switching on the <code>&quot;rust-analyzer.cargo.loadOutDirsFromCheck&quot;: true</code> setting fixed it:</p>
<p><img src="images/completion.png" alt="completion" /></p>
<h2><a class="header" href="#auto-completion-with-intellij-rust-plugin" id="auto-completion-with-intellij-rust-plugin">Auto-completion with IntelliJ Rust Plugin</a></h2>
<p><strong>Question</strong></p>
<p>Similar to rust-analyzer, IntelliJ-Family IDEs struggle to autocomplete gdnative types generated at compile-time.</p>
<p><strong>Answer</strong></p>
<p>There are two problems preventing autocompletion of gdnative types in IntelliJ-Rust.</p>
<p>First, the features necessary are (as of writing) considered experimental and must be enabled. Press <code>shift</code> twice to open the find all dialog and type <code>Experimental features...</code> and click the checkbox for <code>org.rust.cargo.evaluate.build.scripts</code>.  Note that <code>org.rust.cargo.fetch.out.dir</code> will also work, but is known to be less performant and may be phased out.</p>
<p>Second, the bindings files generated (~8mb) are above the 2mb limit for files to be processed. As <a href="https://github.com/intellij-rust/intellij-rust/issues/6571#">reported</a> you can increase the limit with the steps below.</p>
<ul>
<li>open custom VM options dialog (<code>Help</code> | <code>Find Action</code> and type <code>Edit Custom VM Options</code>)</li>
<li>add <code>-Didea.max.intellisense.filesize=limitValue</code> line where <code>limitValue</code> is desired limit in KB, for example, 10240. Note, it cannot be more than 20 MB.</li>
<li>restart IDE</li>
</ul>
<h1><a class="header" href="#an-overview-of-gdnative" id="an-overview-of-gdnative">An Overview of GDNative</a></h1>
<p>TODO</p>
<h1><a class="header" href="#testing" id="testing">Testing</a></h1>
<p>TODO</p>
<h1><a class="header" href="#structuring-code-for-testing" id="structuring-code-for-testing">Structuring Code for Testing</a></h1>
<p>TODO</p>
<h1><a class="header" href="#testing-with-the-engine" id="testing-with-the-engine">Testing with the Engine</a></h1>
<p>TODO</p>
<h1><a class="header" href="#exporting" id="exporting">Exporting</a></h1>
<p>Exporting <a href="https://godotengine.org/">Godot</a> projects using <a href="https://github.com/godot-rust/godot-rust">godot-rust</a>
is a 2 steps process:</p>
<ul>
<li>build your Rust code with cargo, which triggers a build of <a href="https://crates.io/crates/gdnative">gdnative crate</a> for the target platform;</li>
<li>do a standard <a href="https://docs.godotengine.org/en/stable/getting_started/workflow/export/exporting_projects.html">Godot export</a>.</li>
</ul>
<p>If the target you are exporting to is the same as the one you are developping on,
the export is straightforward, however when cross-compiling (eg: exporting for a mobile platform,
or building from a Docker image on a CI)
you need to correctly set up a cross-compiler for the target platform. Rust does this very well,
so provided you only write Rust code, cross-compiling is easy.
However to build <a href="https://crates.io/crates/gdnative-sys">gdnative-sys</a> you need a working C/C++
cross compiler with, among other things, the correct headers and linker.</p>
<p>How to set up such a cross-compiler depends on the source and the target platform.</p>
<h1><a class="header" href="#android" id="android">Android</a></h1>
<p><strong>Disclaimer</strong>: <em>Currently, the following steps are tested and confirmed to work on Linux only.</em></p>
<p>In order to export to Android, we need to compile our Rust source for the appropriate targets. Unlike compiling for our native targets, there are a few extra steps involved with cross-compiling for another target.</p>
<h2><a class="header" href="#installing-prerequisites" id="installing-prerequisites">Installing prerequisites</a></h2>
<p>First, we need to install the <strong>Android SDK</strong> with <strong>NDK</strong> enabled. This contains the necessary tools for each architecture. Once the Android SDK is installed, open Editor Settings in the Godot GUI (<em>Editor &gt; Editor Settings &gt; Export &gt; Android</em>) and set the <strong>absolute paths</strong> to <code>adb</code>, <code>jarsigner</code>, and the debug keystore (<code>debug.keystore</code>), all of which can be found in the Android SDK installation.</p>
<p>Then, we'll install the Rust toolchains for the targets we want to support:</p>
<pre><code class="language-bash">rustup target add aarch64-linux-android    # for arm64 (64-bit)
rustup target add x86_64-linux-android     # for x86_64 (64-bit)
</code></pre>
<h3><a class="header" href="#32-bit-targets" id="32-bit-targets">32-bit targets</a></h3>
<p>The <code>aarch64-linux-android</code> and <code>x86_64-linux-android</code> toolchains are our top priorities, because Google <a href="https://android-developers.googleblog.com/2019/01/get-your-apps-ready-for-64-bit.html">has been requiring 64-bit binaries</a> for all new apps on Play Store since August 2019, and will stop serving 32-bit apps in 2021. If you, nevertheless, want to support 32-bit targets, there are a few more dependencies to install.</p>
<blockquote>
<h3><a class="header" href="#a-bit-of-context" id="a-bit-of-context">A bit of context</a></h3>
<p>There are two major CPU providers in the Android ecosystem: ARM and Intel.</p>
<p>They were primarily supporting 32-bit OS, with notably <a href="https://en.wikipedia.org/wiki/ARM_architecture#32-bit_architecture"><strong>ARMv7</strong></a> and <a href="https://en.wikipedia.org/wiki/X86"><strong>x86</strong></a> architectures, until they started supporting 64-bit OS, by introducing <a href="https://en.wikipedia.org/wiki/ARM_architecture#64/32-bit_architecture"><strong>ARMv8-A</strong></a> (often called <strong>ARM64</strong>) and <a href="https://en.wikipedia.org/wiki/X86-64"><strong>x86-64</strong></a> (often called <strong>Intel 64</strong> or <strong>AMD64</strong>, in reference to a <a href="https://en.wikipedia.org/wiki/X86-64#History_2">long-time conflict</a> between Intel and AMD).</p>
<p><strong>Aarch64</strong> is the 64-bit execution state that is introduced in ARM64 chips. <a href="https://en.wikipedia.org/wiki/P6_%28microarchitecture%29"><strong>i686</strong></a> (also called <strong>P6</strong>) is actually the sixth-generation Intel x86 microarchitecture.</p>
<p>Generally speaking, 32-bit programs can run on 64-bit systems, but 64-bit programs won't run on 32-bit systems.</p>
</blockquote>
<h4><a class="header" href="#rust-toolchains-for-32-bit-targets" id="rust-toolchains-for-32-bit-targets">Rust toolchains for 32-bit targets</a></h4>
<pre><code class="language-bash">rustup target add armv7-linux-androideabi  # for armv7 (32-bit)
rustup target add i686-linux-android       # for x86 (32-bit)
</code></pre>
<h4><a class="header" href="#gcc-libraries-for-cross-compilation" id="gcc-libraries-for-cross-compilation"><code>gcc</code> libraries for cross-compilation</a></h4>
<p>On Windows, we will need to setup a <a href="https://sourceforge.net/projects/mingw-w64/">32-bit/64-bit compatible MinGW</a> instance.</p>
<p>On UNIX-like systems, the required packages are usually available under different names in the package managers for each distribution. On Debian-based Linuxes (including Ubuntu), for example, the required libraries can be installed using <code>apt</code>:</p>
<pre><code class="language-bash">apt-get update
apt-get install g++-multilib gcc-multilib libc6-dev-i386 -y
</code></pre>
<h2><a class="header" href="#setting-up-cargo" id="setting-up-cargo">Setting up Cargo</a></h2>
<p>To make Cargo aware of the proper platform-specific linkers that it needs to use for Android targets, we need to put the paths to the binaries in the Cargo configuration file, which can be found (or created) at <code>$HOME/.cargo/config</code> on UNIX-like systems, or <code>%USERPROFILE%\.cargo\config</code> on Windows), using <a href="https://doc.rust-lang.org/cargo/reference/config.html#target"><code>[target]</code> tables</a>:</p>
<pre><code class="language-toml">[target.armv7-linux-androideabi]
linker = &quot;/usr/local/lib/android/sdk/ndk-bundle/toolchains/llvm/prebuilt/linux-x86_64/bin/armv7a-linux-androideabi29-clang&quot;
</code></pre>
<p>... where the value of <code>linker</code> is an <strong>absolute path</strong> to the Android SDK linker for the target triple. Assuming <code>$ANDROID_SDK_ROOT</code> is the Android SDK path, these binaries can be found at:</p>
<ul>
<li>Windows: <code>$ANDROID_SDK_ROOT\ndk\&lt;NDK-VERSION&gt;\toolchains\llvm\prebuilt\windows-x86_64\bin\</code>, where <code>&lt;NDK-VERSION&gt;</code> is the installed NDK instance version</li>
<li>UNIX-like systems: <code>$ANDROID_SDK_ROOT/ndk-bundle/toolchains/llvm/prebuilt/linux-x86_64/bin/</code></li>
</ul>
<p>Repeat for all targets installed in the previous step, until we get something that looks like:</p>
<pre><code class="language-toml"># Example configuration on an UNIX-like system. `29` is the Android API version.

[target.armv7-linux-androideabi]
linker = &quot;/usr/local/lib/android/sdk/ndk-bundle/toolchains/llvm/prebuilt/linux-x86_64/bin/armv7a-linux-androideabi29-clang&quot;

[target.aarch64-linux-android]
linker = &quot;/usr/local/lib/android/sdk/ndk-bundle/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android29-clang&quot;

[target.i686-linux-android]
linker = &quot;/usr/local/lib/android/sdk/ndk-bundle/toolchains/llvm/prebuilt/linux-x86_64/bin/i686-linux-android29-clang&quot;

[target.x86_64-linux-android]
linker = &quot;/usr/local/lib/android/sdk/ndk-bundle/toolchains/llvm/prebuilt/linux-x86_64/bin/x86_64-linux-android29-clang&quot;
</code></pre>
<h2><a class="header" href="#setting-up-environment-variables-for-gdnative-sys" id="setting-up-environment-variables-for-gdnative-sys">Setting up environment variables for <code>gdnative-sys</code></a></h2>
<p>The <code>gdnative-sys</code> crate can infer include paths for Android targets, but it requires the following environment variables:</p>
<ul>
<li><code>$JAVA_HOME</code>, which should point to the installed JDK instance.</li>
<li><code>$ANDROID_SDK_ROOT</code>, which should point to the Android SDK root (which contains the <code>ndk-bundle</code> directory).</li>
</ul>
<p>Depending on your installation, these environment variables might have already been set. Otherwise, the variables may be set in bash:</p>
<pre><code class="language-bash">export JAVA_HOME=/path/to/jdk
export ANDROID_SDK_ROOT=/path/to/android/sdk
</code></pre>
<p>... or in PowerShell on Windows:</p>
<pre><code class="language-powershell">$env:JAVA_HOME = &quot;C:\path\to\jdk&quot;
$env:ANDROID_SDK_ROOT = &quot;C:\path\to\android\sdk&quot;
</code></pre>
<h2><a class="header" href="#building-the-gdnative-library" id="building-the-gdnative-library">Building the GDNative library</a></h2>
<p>Finally, we can now build the GDNative library with Cargo for one or multiple targets:</p>
<pre><code class="language-bash">cargo build --release --target x86_64-linux-android
</code></pre>
<p><strong>Important note</strong>: ARM and x86 are, by design, different architectures. It is normal to get errors while running <code>cargo test</code> with a Rust library targeting ARMv7 on a x86-64 CPU, for example, since the CPU is unable to handle it.</p>
<h2><a class="header" href="#exporting-in-godot" id="exporting-in-godot">Exporting in Godot</a></h2>
<h3><a class="header" href="#linking-to-android-binaries-in-gdns" id="linking-to-android-binaries-in-gdns">Linking to Android binaries in <code>.gdns</code></a></h3>
<p>After building the GDNative libraries, we need to link them to Godot, by adding new entries in the GDNative library declaration file (<code>*.gdnlib</code>) for <code>Android.armeabi-v7a</code> (ARMv7),  <code>arm64-v8a</code> (ARM64), <code>Android.x86</code> (x86) and/or <code>Android.x86_64</code> (x86-64), depending of the toolchains we actually used in previous steps:</p>
<pre><code>[entry]

Android.armeabi-v7a=&quot;res://target/armv7-linux-androideabi/release/lib.so&quot;
Android.arm64-v8a=&quot;res://target/aarch64-linux-android/release/lib.so&quot;
Android.x86=&quot;res://target/i686-linux-android/release/lib.so&quot;
Android.x86_64=&quot;res://target/x86_64-linux-android/release/lib.so&quot;

[dependencies]

Android.armeabi-v7a=[  ]
Android.arm64-v8a=[  ]
Android.x86=[  ]
Android.x86_64=[  ]
</code></pre>
<h3><a class="header" href="#apk-signing-for-publication" id="apk-signing-for-publication">APK signing for publication</a></h3>
<p>Usually, we can choose between releasing an app in <strong>Debug</strong> or <strong>Release</strong> mode. However, the Release mode is required when officially releasing to Play Store.</p>
<p>In order to configure Godot to sign Release APKs, we'll first need to generate a project-specific Release keystore using <code>keytool</code>, and set up an alias and a single password (as explained in the <a href="https://docs.godotengine.org/en/3.2/getting_started/workflow/export/exporting_for_android.html#exporting-for-google-play-store">Godot docs</a>, <code>-storepass</code> and <code>-keypass</code> option values must be the same):</p>
<pre><code class="language-bash">keytool -genkeypair -v -keystore path/to/my.keystore -alias some-alias -keyalg RSA -keysize 2048 -validity 10000 -storepass my-password -keypass my-password
</code></pre>
<p>Then, we will register its path in Export Settings (<em>Project &gt; Export</em>) or <code>export_presets.cfg</code>. Please note that passwords entered in the GUI will be stored in <code>export_presets.cfg</code>. Be sure to not commit it into any VCS!</p>
<pre><code># Remember to not commit the password as is in VCS!
keystore/release=&quot;path/to/my.keystore&quot;
keystore/release_user=&quot;some-alias&quot;
keystore/release_password=&quot;my-password&quot;
</code></pre>
<h3><a class="header" href="#exporting-1" id="exporting-1">Exporting</a></h3>
<p>Finally, we can now export the project using the GUI (<em>Project &gt; Export... &gt; Android (Runnable)</em>) and uncheck &quot;<em>Export with Debug</em>&quot; in GUI when being asked to enter APK file name. We may also use one of the following commands from the CLI to do the same:</p>
<pre><code class="language-bash"># Debug mode
godot --export-debug &quot;Android&quot; path/to/my.apk

# Release mode
godot --export &quot;Android&quot; path/to/my.apk
</code></pre>
<p>When trying to install the app directly from the APK on an Android device, Play Protect may display a warning explaining that <em>the app developers are not recognized, so the app may be unsafe</em>. This is the expected behavior for an APK in Release mode that isn't actually released on Play Store.</p>
<p>If not planning to release on Play Store, one may file an appeal from Play Protect using <a href="https://support.google.com/googleplay/android-developer/contact/protectappeals">a form provided by Google</a>.</p>
<h1><a class="header" href="#ios" id="ios">iOS</a></h1>
<p>TODO</p>
<h1><a class="header" href="#mac-os-x" id="mac-os-x">Mac OS X</a></h1>
<p><strong>Disclaimer</strong>: <em>Currently, the following steps are tested and confirmed to work on Linux only.</em></p>
<h2><a class="header" href="#use-case" id="use-case">Use case</a></h2>
<p>Exporting for Mac OS X is interesting if:</p>
<ul>
<li>you do not have access to Apple hardware</li>
<li>you want to build from a CI, typically on a Docker image</li>
</ul>
<p>If you have access to a real Mac, building natively is easier.</p>
<h2><a class="header" href="#why-is-this-complex-" id="why-is-this-complex-">Why is this complex ?</a></h2>
<p>Cross-compiling Rust programs for Mac OS X is as simple as:</p>
<pre><code class="language-sh">rustup target add x86_64-apple-darwin
cargo build --target x86_64-apple-darwin
</code></pre>
<p>However to build <a href="https://crates.io/crates/gdnative-sys">gdnative-sys</a> you
need a Mac OS X C/C++ compiler, the Rust compiler is not enough. More precisely you need
an SDK which usually comes with <a href="https://developer.apple.com/xcode/">Xcode</a>.
For Mac users, this SDK is &quot;just there&quot; but when cross-compiling, it is
typically missing, even if your compiler is able to produce Mac OS X compatible binaries.</p>
<p>The most common error is:</p>
<pre><code>fatal error: 'TargetConditionals.h' file not found
</code></pre>
<p>Installing just this file is not enough, this error is usually a consequence
of the whole SDK missing, so there is no chance you can get a build.</p>
<p>What you need to do is:</p>
<ul>
<li>download the SDK</li>
<li>fix all paths and other details so that it ressembles a Mac OS X environment</li>
<li>then build with <code>cargo build --target x86_64-apple-darwin</code></li>
</ul>
<p>Hopefully, the first two steps, downloading the SDK and fixing details,
are handled by a tool called <a href="https://github.com/tpoechtrager/osxcross">osxcross</a>
which is just about setting up a working C/C++ compiler on Linux.</p>
<h2><a class="header" href="#howto" id="howto">Howto</a></h2>
<pre><code class="language-sh"># make sure you have a proper C/C++ native compiler first, as a suggestion:
sudo apt-get install llvm-dev libclang-dev clang libxml2-dev libz-dev

# change the following path to match your setup
export MACOSX_CROSS_COMPILER=$HOME/macosx-cross-compiler

install -d $MACOSX_CROSS_COMPILER/osxcross
install -d $MACOSX_CROSS_COMPILER/cross-compiler
cd $MACOSX_CROSS_COMPILER
git clone https://github.com/tpoechtrager/osxcross &amp;&amp; cd osxcross

# picked this version as they work well with godot-rust, feel free to change
git checkout 7c090bd8cd4ad28cf332f1d02267630d8f333c19
</code></pre>
<p>At this stage you need to <a href="https://github.com/tpoechtrager/osxcross#packaging-the-sdk">download and package the SDK</a>
which can not be distributed with osxcross for legal reasons.
<a href="https://www.apple.com/legal/sla/docs/xcode.pdf">Please ensure you have read and understood the Xcode license terms before continuing</a>.</p>
<p>You should now have an SDK file, for example <code>MacOSX10.10.sdk.tar.xz</code>.</p>
<pre><code class="language-sh"># move the file where osxcross expects it to be
mv MacOSX10.10.sdk.tar.xz $MACOSX_CROSS_COMPILER/osxcross/tarballs/
# build and install osxcross
UNATTENDED=yes OSX_VERSION_MIN=10.7 TARGET_DIR=$MACOSX_CROSS_COMPILER/cross-compiler ./build.sh
</code></pre>
<p>At this stage, you should have, in <code>$MACOSX_CROSS_COMPILER/cross-compiler</code>,
a working cross-compiler.</p>
<p>Now you need to tell Rust to use it when linking
Mac OS X programs:</p>
<pre><code class="language-sh">echo &quot;[target.x86_64-apple-darwin]&quot; &gt;&gt; $HOME/.cargo/config
find $MACOSX_CROSS_COMPILER -name x86_64-apple-darwin14-cc -printf 'linker = &quot;%p&quot;\n' &gt;&gt; $HOME/.cargo/config
echo &gt;&gt; $HOME/.cargo/config
</code></pre>
<p>After this, your <code>$HOME/.cargo/config</code> (not the <code>cargo.toml</code> file in your project, this is a different file)
should contain:</p>
<pre><code class="language-toml">[target.x86_64-apple-darwin]
linker = &quot;/home/my-user-name/macosx-cross-compiler/cross-compiler/bin/x86_64-apple-darwin14-cc&quot;
</code></pre>
<p>Then, we need to also tell the compiler to use the right compiler and headers.
In our example, with SDK 10.10, the env vars we need to export are:</p>
<pre><code class="language-sh">C_INCLUDE_PATH=$MACOSX_CROSS_COMPILER/cross-compiler/SDK/MacOSX10.10.sdk/usr/include
CC=$MACOSX_CROSS_COMPILER/cross-compiler/bin/x86_64-apple-darwin14-cc
</code></pre>
<p>You probably do not want to export those permanently as they are very
specific to building for Mac OS X so they are typically passed at each
call to <code>cargo</code>, eg:</p>
<pre><code class="language-sh">C_INCLUDE_PATH=$MACOSX_CROSS_COMPILER/cross-compiler/SDK/MacOSX10.10.sdk/usr/include CC=$MACOSX_CROSS_COMPILER/cross-compiler/bin/x86_64-apple-darwin14-cc cargo build --release --target x86_64-apple-darwin
</code></pre>
<p>As a consequence, you do <em>not</em> need to put <code>$MACOSX_CROSS_COMPILER/cross-compiler/bin</code> in your <code>$PATH</code> if
you only plan to export <a href="https://github.com/godot-rust/godot-rust">godot-rust</a> based programs, as the
binary needs to be explicitly overloaded.</p>
<h2><a class="header" href="#exporting-2" id="exporting-2">Exporting</a></h2>
<p>Once your <code>.dylib</code> file is built, a standard Godot export should work:</p>
<pre><code class="language-sh">godot --export &quot;Mac OSX&quot; path/to/my.zip
</code></pre>
<p>Note that when exporting from a non Mac OS X platform, it is not possible to build a <code>.dmg</code>.
Instead, a <code>.zip</code> is produced. Again, the tool required to build Mac OS X disk images is
only available on Mac OS X. The <code>.zip</code> works fine though, it just contains <code>my.app</code>
folder, ready to use.</p>
<p>Double-check your <code>.dylib</code> file is there.</p>
<h2><a class="header" href="#useful-links" id="useful-links">Useful links</a></h2>
<ul>
<li>https://github.com/tpoechtrager/osxcross : tool used to install the Mac OS X SDK on Linux</li>
<li>https://wapl.es/rust/2019/02/17/rust-cross-compile-linux-to-macos.html : a complete tutorial on how to use osxcross</li>
</ul>
<h1><a class="header" href="#advanced-guides" id="advanced-guides">Advanced Guides</a></h1>
<h1><a class="header" href="#using-custom-builds-of-godot" id="using-custom-builds-of-godot">Using custom builds of Godot</a></h1>
<p>Sometimes, users might need to use a different version of the engine that is different from the default one, or is a custom build. In order to use <code>godot-rust</code> with them, one would need to create a custom version of the <code>gdnative-bindings</code> crate, generated from an <code>api.json</code> from the custom build. This guide walks through the necessary steps to do so.</p>
<p>First, obtain the source code for <code>gdnative-bindings</code> from crates.io. For this guide, we'll use <a href="https://github.com/Xion/cargo-download/"><code>cargo-download</code></a> to accomplish this:</p>
<pre><code># Install the `cargo-download` sub-command if it isn't installed yet
cargo install cargo-download

# Download and unpack the crate
cargo download gdnative-bindings==0.9.0 &gt;gdnative-bindings.tar.gz
tar -xf gdnative-bindings.tar.gz
</code></pre>
<p>You should be able to find the source code for the crate in a <code>gdnative-bindings-{version}</code> directory. Rename it to a distinctive name like <code>gdnative-bindings-custom</code> and update the <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;gdnative-bindings-custom&quot;
</code></pre>
<p>When downloading the crate, please specify the exact version of the crate that is specified in the <code>Cargo.toml</code> of <code>gdnative</code>. This is necessary because the generated bindings depend on internal interfaces that may change between non-breaking versions of <code>gdnative</code>.</p>
<p>After source is obtained, replace the API description file with one generated by your specific Godot build:</p>
<pre><code>cd /path/to/gdnative-bindings-custom
/path/to/godot --gdnative-generate-json-api api.json

# Try to build and see if it works
cargo build
</code></pre>
<p>If everything goes well, you can now update the dependencies of your GDNative library to use this custom bindings crate:</p>
<pre><code class="language-toml">[dependencies]

# Use the exact version corresponding to `gdnative-bindings`, and disable the default re-export.
gdnative = { version = &quot;=0.9.0&quot;, default-features = false, features = [] }

# Use your custom bindings crate as a path dependency
gdnative-bindings-custom = { path = &quot;/path/to/gdnative-bindings-custom&quot; }
</code></pre>
<p>Here, <code>gdnative</code> is specified using an exact version because the bindings generator is an internal dependency. When using custom binding crates, care must be taken to ensure that the version of the bindings crate used as the base matches the one specified in the <code>Cargo.toml</code> of the <code>gdnative</code> crate exactly, even for updates that are considered non-breaking in the <code>gdnative</code> crate. Using an exact version bound here helps prevent unintentional updates that may break the build.</p>
<p>Finally, replace references to <code>gdnative::api</code> with <code>gdnative-bindings-custom</code>. You should now be able to use the APIs in your custom build in Rust!</p>
<h2><a class="header" href="#generating-documentation" id="generating-documentation">Generating documentation</a></h2>
<p>However, if you try to generate documentation with rustdoc at this point, you might notice that documentation might be missing or wrong for some of the types or methods. This is due to documentation being stored separately from the API description itself, and can be easily fixed if you have access to the source code from which your custom Godot binary is built.</p>
<p>To get updated documentation, you only need to copy all the documentation XMLs from <code>doc/classes</code> in the Godot source tree, to the <code>docs</code> directory in the <code>gdnative-bindings</code> source. After the files are copied, you should be able to get correct documentation for the API.</p>
<h1><a class="header" href="#migrating-from-godot-rust-08x" id="migrating-from-godot-rust-08x">Migrating from godot-rust 0.8.x</a></h1>
<p>In version 0.9, we are attempting to resolve many long-standing problems in the older API. As a result, there are many breaking changes in the public interface. This is a quick guide to the new API for users that have used older versions.</p>
<h2><a class="header" href="#module-organization-and-naming" id="module-organization-and-naming">Module organization and naming</a></h2>
<h3><a class="header" href="#generated-api-types" id="generated-api-types">Generated API types</a></h3>
<p>Generated types now live under the <code>gdnative::api</code> module. This makes the top-level namespace easier to navigate in docs. If you have used glob imports like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use gdnative::*;
<span class="boring">}
</span></code></pre></pre>
<p>..., you should change this to:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use gdnative::prelude::*;
use gdnative::api::*;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#generated-property-accessors" id="generated-property-accessors">Generated property accessors</a></h3>
<p>Generated getters of properties are no longer prefixed with <code>get_</code>. This <strong>does not</strong> affect other methods that start with <code>get_</code> that are not getters, like <code>File::get_8</code>.</p>
<h3><a class="header" href="#separation-of-core-types-and-nativescript-code" id="separation-of-core-types-and-nativescript-code">Separation of core types and NativeScript code</a></h3>
<p>Core types, like <code>VariantArray</code>, <code>Color</code>, and <code>Dictionary</code> are moved to the <code>gdnative::core_types</code> module, while NativeScript supporting code like <code>NativeClass</code>, <code>Instance</code> and <code>init</code> code are moved to the <code>gdnative::nativescript</code> module. Most of the commonly-used types are re-exported in the <code>prelude</code>, but if you prefer individual imports, the paths need to be changed accordingly.</p>
<h3><a class="header" href="#api-enums" id="api-enums">API enums</a></h3>
<p>C enums in the API are now generated in submodules of <code>gdnative_bindings</code> named after their associated objects. Common prefixes are also stripped from the constant names. The constants are accessed as associated constants:</p>
<h4><a class="header" href="#example" id="example">Example</a></h4>
<p>In 0.8, you would write this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use gdnative::*;

object.connect(
    &quot;foo&quot;.into(),
    owner.to_object(),
    &quot;_handle_foo&quot;.into(),
    VariantArray::new(),
    Object::CONNECT_DEFERRED,
);
<span class="boring">}
</span></code></pre></pre>
<p>In 0.9, this should now be written as:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use gdnative::prelude::*;
use gdnative::api::object::ConnectFlags;

object.connect(&quot;foo&quot;, owner, &quot;_handle_foo&quot;, VariantArray, ConnectFlags::DEFERRED.into());
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#fixed-typos" id="fixed-typos">Fixed typos</a></h3>
<p>Typos in variant names of <code>VariantOperator</code> and <code>GodotError</code> are fixed. Change to the correct names if this breaks your code.</p>
<h2><a class="header" href="#changes-to-derive-macros" id="changes-to-derive-macros">Changes to derive macros</a></h2>
<p>The <code>NativeScript</code> derive macro now looks for <code>new</code> instead of <code>_init</code> as the constructor.</p>
<h3><a class="header" href="#example-1" id="example-1">Example</a></h3>
<p>In 0.8, you would write this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
#[inherit(Object)]
pub struct Thing;

impl Thing {
    fn _init(_owner: Object) -&gt; Self {
        Thing
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In 0.9, this should now be written as:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
#[inherit(Object)]
pub struct Thing;

impl Thing {
    // `owner` may also be `TRef&lt;Object&gt;`, like in exported methods.
    fn new(_owner: &amp;Object) -&gt; Self {
        Thing
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#argument-casts" id="argument-casts">Argument casts</a></h2>
<p>Generated methods taking objects, <code>Variant</code>, and <code>GodotString</code> are now made generic using <code>impl Trait</code> in argument position. This make calls much less verbose, but may break inference for some existing code. If you have code that looks like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut binds = VariantArray::new();
binds.push(&amp;42.to_variant());
binds.push(&amp;&quot;foo&quot;.to_variant());
thing.connect(
    &quot;foo&quot;.into(),
    Some(owner.to_object()),
    &quot;bar&quot;.into(),
    binds,
    0,
)
<span class="boring">}
</span></code></pre></pre>
<p>..., you should change this to:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut binds = VariantArray::new();
binds.push(42);
binds.push(&quot;foo&quot;);
thing.connect(&quot;foo&quot;, owner, &quot;bar&quot;, binds, 0);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#explicit-nulls" id="explicit-nulls">Explicit nulls</a></h3>
<p>A side effect of accepting generic arguments is that inference became tricky for <code>Option</code>. As a solution for this, an explicit <code>Null</code> type is introduced for use as method arguments. To obtain a <code>Null</code> value, you may use either <code>GodotObject::null()</code> or <code>Null::null()</code>. You may also call <code>null</code> on specific types since it is a trait method for all API types, e.g. <code>Node::null()</code> or <code>Object::null()</code>.</p>
<p>For example, to clear the script on an object, instead of:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thing.set_script(None);
<span class="boring">}
</span></code></pre></pre>
<p>..., you should now write:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thing.set_script(Null::null());
<span class="boring">}
</span></code></pre></pre>
<p>This is arguably less convenient, but passing explicit nulls should be rare enough a use case that the benefits of having polymorphic arguments are much more significant.</p>
<h2><a class="header" href="#object-semantics" id="object-semantics">Object semantics</a></h2>
<p>In 0.9, the way Godot objects are represented in the API is largely remodeled to closely match the behavior of Godot. For the sake of illustration, we'll use the type <code>Node</code> in the following examples.</p>
<p>In 0.8.x, bare objects like <code>Node</code> are either unsafe or reference-counted pointers. Some of the methods require <code>&amp;mut</code> receivers, but there is no real guarantee of uniqueness since the pointers may be cloned or aliased freely. This restriction is not really useful for safety, and requires a lot of operations to be <code>unsafe</code>.</p>
<p>This is changed in 0.9 with the typestate pattern, which will be explained later. Now, there are three representations of Godot objects, with different semantics:</p>
<table><thead><tr><th>Type</th><th>Terminology</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>&amp;'a Node</code></td><td>bare reference</td><td>reference assumed or guaranteed to be valid and uncontended during <code>'a</code></td></tr>
<tr><td><code>Ref&lt;Node, Access&gt;</code></td><td>persistent reference</td><td>stored reference whose validity is not always known, depending on the typestate <code>Access</code></td></tr>
<tr><td><code>TRef&lt;'a, Node, Access&gt;</code></td><td>temporary reference</td><td>reference assumed or guaranteed to be valid and uncontended during <code>'a</code>, with added typestate tracking</td></tr>
</tbody></table>
<p>Note that owned bared objects, like <code>Node</code>, no longer exist in the new API. They should be replaced with <code>Ref</code> or <code>TRef</code> depending on the situation:</p>
<ul>
<li>In persistent data structures, like <code>NativeScript</code> structs, use <code>Ref&lt;Node, Access&gt;</code>.</li>
<li>When taking the <code>owner</code> argument, use <code>&amp;Node</code> or <code>TRef&lt;'a, Node, Shared&gt;</code>. The latter form allows for more safe operations, like using as method arguments, thanks to the typestate.</li>
<li>When taking objects from the engine, like as arguments other than <code>owner</code>, use <code>Ref&lt;Node, Shared&gt;</code>.</li>
<li>When passing objects to the engine as arguments or return values, use <code>&amp;Ref&lt;Node, Shared&gt;</code>, <code>Ref&lt;Node, Unique&gt;</code>, or <code>TRef&lt;'a, Node, Shared&gt;</code>.</li>
<li>When passing temporary references around in internal code, use <code>TRef&lt;'a, Node, Access&gt;</code>.</li>
</ul>
<p>All objects are also seen as having interior mutability in Rust parlance, which means that all API methods now take <code>&amp;self</code> instead of <code>&amp;mut self</code>. For more information about shared (immutable) and unique (mutable) references, see <a href="https://docs.rs/dtolnay/0.0.9/dtolnay/macro._02__reference_types.html">Accurate mental model for Rust's reference types</a> by dtolnay.</p>
<p>Unlike the previous versions requiring ubiquitous <code>unsafe</code>s, the new API allows for clearer separation of safe and unsafe code in Rust. In general, <code>unsafe</code> is only necessary around the border between Godot and Rust, while most of the internal code can now be safe.</p>
<p>To convert a <code>Ref</code> to a <code>TRef</code>, use <code>Ref::assume_safe</code> or <code>Ref::as_ref</code> depending on the object type and typestate. To convert non-unique <code>TRef</code>s to <code>Ref</code>s, use <code>TRef::claim</code>. Bare references are usually obtained through <code>Deref</code>, and it's not recommended to use them directly.</p>
<p>For detailed information about the API, see the type-level documentation on <code>Ref</code> and <code>TRef</code>.</p>
<h3><a class="header" href="#example-2" id="example-2">Example</a></h3>
<p>If you prefer to learn by examples, here is the simplified code for instancing child scenes in the dodge-the-creeps example in 0.8. Note how everything is <code>unsafe</code> due to <code>Node</code>s being manually-managed:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
#[inherit(Node)]
pub struct Main {
    #[property]
    mob: PackedScene,
}

#[methods]
impl Main {
    #[export]
    unsafe fn on_mob_timer_timeout(&amp;self, owner: Node) {
        let mob_scene: RigidBody2D = instance_scene(&amp;self.mob).unwrap();
        let direction = rng.gen_range(-PI / 4.0, PI / 4.0);
        mob_scene.set_rotation(direction);
        owner.add_child(Some(mob_scene.to_node()), false);
    }
}

unsafe fn instance_scene&lt;Root&gt;(scene: &amp;PackedScene) -&gt; Result&lt;Root, ManageErrs&gt;
where
    Root: gdnative::GodotObject,
{
    let inst_option = scene.instance(PackedScene::GEN_EDIT_STATE_DISABLED);

    if let Some(instance) = inst_option {
        if let Some(instance_root) = instance.cast::&lt;Root&gt;() {
            Ok(instance_root)
        } else {
            Err(ManageErrs::RootClassNotRigidBody2D(
                instance.name().to_string(),
            ))
        }
    } else {
        Err(ManageErrs::CouldNotMakeInstance)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In 0.9, this can now be written as (with added type annotations and explanations for clarity):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
#[inherit(Node)]
pub struct Main {
    #[property]
    mob: Ref&lt;PackedScene, Shared&gt;,
}

#[methods]
impl Main {
    #[export]
    fn on_mob_timer_timeout(&amp;self, owner: &amp;Node) {
        // This assumes that the `PackedScene` cannot be mutated from
        // other threads during this method call. This is fine since we
        // know that no other scripts mutate the scene at runtime.
        let mob: TRef&lt;PackedScene, Shared&gt; = unsafe { self.mob.assume_safe() };

        // Call the internal function `instance_scene` using the `TRef`
        // produced by `assume_safe`. This is safe because we already
        // assumed the safety of the object.
        let mob_scene: Ref&lt;RigidBody2D, Unique&gt; = instance_scene(mob);

        // `mob_scene` can be used directly because it is a `Unique`
        // reference -- we just created it and there can be no other
        // references to it in the engine.
        let direction = rng.gen_range(-PI / 4.0, PI / 4.0);
        mob_scene.set_rotation(direction);

        // `mob_scene` can be passed safely to the `add_child` method
        // by value since it is a `Unique` reference.
        // Note that there is no need to cast the object or wrap it in an
        // `Option`.
        owner.add_child(mob_scene, false);

        // Note that access to `mob_scene` is lost after it's passed
        // to the engine. If you need to use it after doing that,
        // convert it into a `Shared` one with `into_shared().assume_safe()`
        // first.
    }
}

// The `instance_scene` function now expects `TRef` arguments, which expresses
// at the type level that this function expects a valid and uncontended
// reference during the call.
//
// Note that this makes the interface safe.
fn instance_scene&lt;Root&gt;(scene: TRef&lt;PackedScene, Shared&gt;) -&gt; Ref&lt;Root, Unique&gt;
where
    // More static guarantees are now available for `cast` using the `SubClass`
    // trait. This ensures that you can only downcast to possible targets.
    Root: gdnative::GodotObject&lt;RefKind = ManuallyManaged&gt; + SubClass&lt;Node&gt;,
{
    // Instancing the scene is safe since `scene` is assumed to be safe.
    let instance = scene
        .instance(PackedScene::GEN_EDIT_STATE_DISABLED)
        .expect(&quot;should be able to instance scene&quot;);

    // `PackedScene::instance` is a generated API, so it returns
    // `Ref&lt;_, Shared&gt;` by default. However, we know that it actually creates
    // a new `Node` for us, so we can convert it to a `Unique` reference using
    // the `unsafe` `assume_unique` method.
    let instance = unsafe { instance.assume_unique() };

    // Casting to the `Root` type is also safe now.
    instance
        .try_cast::&lt;Root&gt;()
        .expect(&quot;root node type should be correct&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#casting" id="casting">Casting</a></h2>
<p>The casting API is made more convenient with 0.9, using the <code>SubClass</code> trait. Casting is now covered by two generic methods implemented on all object reference types: <code>cast</code> and <code>upcast</code>. Both methods enforce cast validity statically, which means that the compiler will complain about casts that will always fail at runtime. The generated <code>to_*</code> methods are removed in favor of <code>upcast</code>.</p>
<h3><a class="header" href="#examples" id="examples">Examples</a></h3>
<h4><a class="header" href="#casting-a-node-to-object" id="casting-a-node-to-object">Casting a <code>Node</code> to <code>Object</code></a></h4>
<p>In 0.8, you would write either of:</p>
<ul>
<li><code>node.to_object()</code></li>
<li><code>node.cast::&lt;Object&gt;().unwrap()</code></li>
</ul>
<p>In 0.9, this should now be written as <code>node.upcast::&lt;Object&gt;()</code>. This is a no-op at runtime because <code>Node</code> is a subclass of <code>Object</code>.</p>
<h4><a class="header" href="#casting-an-object-to-node" id="casting-an-object-to-node">Casting an <code>Object</code> to <code>Node</code></a></h4>
<p>The API for downcasting to concrete types is unchanged. You should still write <code>object.cast::&lt;Node&gt;().unwrap()</code>.</p>
<h4><a class="header" href="#casting-to-a-type-parameter" id="casting-to-a-type-parameter">Casting to a type parameter</a></h4>
<p>In 0.8, you would write this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn polymorphic_cast&lt;T: GodotObject&gt;(obj: Object) -&gt; Option&lt;T&gt; {
    obj.cast()
}
<span class="boring">}
</span></code></pre></pre>
<p>In 0.9, casting to a type parameter is a bit more complicated due to the addition of static checks. You should now write:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn polymorphic_cast&lt;T, Access&gt;(
    obj: TRef&lt;Object, Access&gt;,
) -&gt; Option&lt;TRef&lt;T, Access&gt;&gt;
where
    T: GodotObject + SubClass&lt;Object&gt;,
    Access: ThreadAccess,
{
    obj.cast()
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that this function is also polymorphic over the <code>Access</code> typestate, which is explained the the following section.</p>
<h2><a class="header" href="#typestates" id="typestates">Typestates</a></h2>
<p>The typestate pattern is introduced in 0.9 to statically provide fine-grained reference safety guarantees depending on thread access state. There are three typestates in the API:</p>
<ul>
<li><code>Shared</code>, for references that may be shared between multiple threads. <code>Shared</code> references are <code>Send</code> and <code>Sync</code>.</li>
<li><code>ThreadLocal</code>, for references that may only be shared on the current thread. <code>ThreadLocal</code> references are <code>!Send</code> and <code>!Sync</code>. This is because sending a <code>ThreadLocal</code> reference to another thread violates the invariant.</li>
<li><code>Unique</code>, for references that are <strong>globally unique</strong> (with the exception of specific engine internals like <code>ObjectDB</code>). <code>Unique</code> references are <code>Send</code> but <code>!Sync</code>. These references are always safe to use.</li>
</ul>
<p>Users may convert between typestates using the <code>into_*</code> and <code>assume_*</code> methods found on various types that deal with objects or <code>Variant</code> collections with interior mutability (<code>Dictionary</code> and <code>VariantArray</code>). Doing so has no runtime cost. The documentation should be referred to when calling the unsafe <code>assume_*</code> methods to avoid undefined behavior.</p>
<p>Typestates are encoded in types as the <code>Access</code> type parameter, like the ones in <code>Ref&lt;T, Access&gt;</code> and <code>Dictionary&lt;Access&gt;</code>. These type parameters default to <code>Shared</code>.</p>
<p>The general guidelines for using typestates are as follows:</p>
<ul>
<li>References obtained from the engine are <code>Shared</code> by default. This includes unique objects returned by generated API methods, because there isn't enough information to tell them from others.</li>
<li>Constructors return <code>Unique</code> references.</li>
<li><code>ThreadLocal</code> references are never returned directly. They can be created manually from other references, and can be used Godot objects and collections internally kept in Rust objects.</li>
</ul>
<h3><a class="header" href="#examples-1" id="examples-1">Examples</a></h3>
<h4><a class="header" href="#creating-a-dictionary-and-returning-it" id="creating-a-dictionary-and-returning-it">Creating a <code>Dictionary</code> and returning it</a></h4>
<p>In 0.8, you would write this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[export]
fn dict(&amp;self, _owner: Reference) -&gt; Dictionary {
    let mut dict = Dictionary::new();
    dict.insert(&amp;&quot;foo&quot;.into(), &amp;42.into());
    dict.insert(&amp;&quot;bar&quot;.into(), &amp;1337.into());
    dict
}
<span class="boring">}
</span></code></pre></pre>
<p>In 0.9, this should now be written as (with added type annotations and explanations for clarity):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[export]
fn dict(&amp;self, _owner: &amp;Reference) -&gt; Dictionary&lt;Unique&gt; {
    // `mut` is no longer needed since Dictionary has interior mutability in
    // Rust parlance
    let dict: Dictionary&lt;Unique&gt; = Dictionary::new();

    // It is safe to insert into the `dict` because it is unique. Also note how
    // the conversion boilerplate is no longer needed for `insert`.
    dict.insert(&quot;foo&quot;, 42);
    dict.insert(&quot;bar&quot;, 1337);

    // Owned `Unique` references can be returned directly
    dict
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#using-an-object-argument-other-than-owner" id="using-an-object-argument-other-than-owner">Using an object argument other than <code>owner</code></a></h4>
<p>In 0.8, you would write this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[export]
unsafe fn connect_to(&amp;self, owner: Node, target: Object) {
    target.connect(
        &quot;foo&quot;.into(),
        owner.to_object(),
        &quot;_handle_foo&quot;.into(),
        VariantArray::new(),
        0,
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>In 0.9, this should now be written as (with added type annotations and explanations for clarity):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[export]
// The `Access` parameter defaults to `Shared` for `Ref`, so it can be omitted
// in method signatures.
// Here, we also need to use `TRef` as the owner type, because we need the
// typestate information to pass it into `connect`.
fn connect_to(&amp;self, owner: TRef&lt;Node&gt;, target: Ref&lt;Object&gt;) {
    // Assume that `target` is safe to use for the body of this method.
    let target = unsafe { target.assume_safe() };
    // `TRef` references can be passed directly into methods without the need
    // for casts.
    target.connect(&quot;foo&quot;, owner, &quot;_handle_foo&quot;, VariantArray::new(), 0);
}
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
